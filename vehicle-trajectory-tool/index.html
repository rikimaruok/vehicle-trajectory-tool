<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>車両軌跡作図システム (MVP)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Noto+Sans+JP:wght@400;500;700&family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0"
        rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6;
            /* Blue 500 */
            --primary-hover: #2563eb;
            /* Blue 600 */
            --danger-color: #ef4444;
            /* Red 500 */
            --success-color: #22c55e;
            /* Green 500 */
            --text-color: #1e293b;
            /* Slate 800 */
            --bg-color: #f8fafc;
            /* Slate 50 */
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            --radius: 12px;
            --transition: all 0.2s ease;
        }

        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        /* Canvas Container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: radial-gradient(circle at center, #f1f5f9 1px, transparent 1px) 0 0 / 20px 20px;
            /* Dot pattern */
        }

        canvas {
            display: block;
        }

        /* Floating Toolbar */
        #toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius);
            box-shadow: var(--glass-shadow);
            z-index: 100;
            transition: var(--transition);
        }

        /* Icon Buttons */
        .icon-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            position: relative;
        }

        .icon-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: translateY(-1px);
        }

        .icon-btn:active {
            transform: translateY(0);
        }

        .icon-btn.primary {
            background: var(--primary-color);
            color: white;
        }

        .icon-btn.primary:hover {
            background: var(--primary-hover);
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.5);
        }

        .icon-btn.danger {
            color: var(--danger-color);
        }

        .icon-btn.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Tooltip */
        .icon-btn::after {
            content: attr(title);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .icon-btn:hover::after {
            opacity: 1;
        }

        .icon-btn.active {
            background: var(--primary-color);
            color: white;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Settings Panel (Floating) */
        #settings-panel {
            position: absolute;
            top: 20px;
            left: 80px;
            /* Next to toolbar */
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius);
            box-shadow: var(--glass-shadow);
            z-index: 99;
            padding: 16px;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            gap: 16px;
        }

        #settings-panel.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h2,
        h3 {
            margin: 0;
            font-weight: 600;
            color: var(--text-color);
        }

        h2 {
            font-size: 18px;
            margin-bottom: 8px;
        }

        h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #64748b;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
        }

        input,
        select {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-family: inherit;
            font-size: 13px;
            background: rgba(255, 255, 255, 0.8);
            transition: var(--transition);
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        /* Floating Panels */
        .floating-panel {
            position: absolute;
            top: 60px;
            left: 60px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            width: 280px;
            display: none;
            /* Hidden by default */
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        /* Legend (Floating bottom right) */
        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            padding: 12px;
            border-radius: var(--radius);
            box-shadow: var(--glass-shadow);
            border: 1px solid var(--glass-border);
            font-size: 12px;
            z-index: 90;
            pointer-events: none;
            /* Let clicks pass through if needed, but text selection might be hard */
            pointer-events: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            margin-right: 8px;
        }

        /* Modal Styles (Updated) */
        .modal {
            display: none;
            position: fixed;
            z-index: 200;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
        }

        /* Modal Content */
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 0;
            border: 1px solid #888;
            width: 900px;
            /* Wider for 2 columns */
            max-width: 95%;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor-panel {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            border-right: 1px solid #ccc;
            background: #fff;
        }

        .preview-panel {
            width: 400px;
            padding: 10px;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #previewCanvas {
            border: 1px solid #ccc;
            background: #fff;
            width: 380px;
            height: 500px;
        }

        /* Excel-like Table Layout */
        .params-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
            font-size: 12px;
            border: 1px solid #ccc;
        }

        .params-table td,
        .params-table th {
            border: 1px solid #ccc;
            padding: 0;
            vertical-align: middle;
            height: 24px;
            /* Fixed row height */
        }

        .params-table td:first-child {
            width: 110px;
            background-color: #f0f0f0;
            /* Header-like column */
            padding-left: 5px;
            font-weight: normal;
            color: #333;
        }

        .params-table td:nth-child(2) {
            width: 110px;
            /* Match label column width */
        }

        .params-table input[type="number"] {
            width: 100%;
            height: 100%;
            border: none;
            padding: 0 5px;
            box-sizing: border-box;
            font-size: 12px;
            background: transparent;
            outline: none;
        }

        .params-table input[type="number"]:focus {
            background-color: #e6f7ff;
            box-shadow: inset 0 0 0 2px #1890ff;
        }

        .params-table .unit {
            width: 25px;
            text-align: center;
            background-color: #fafafa;
            color: #666;
        }

        h3 {
            margin-top: 5px;
            margin-bottom: 5px;
            color: #333;
            font-size: 13px;
            font-weight: bold;
            border-bottom: none;
            padding-bottom: 0;
        }

        .close {
            color: #94a3b8;
            font-size: 24px;
            transition: var(--transition);
        }

        .close:hover {
            color: var(--danger-color);
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        /* Range Input Styling */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 2px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
    <!-- PDF.js -->
    <!-- Calibration Distance Modal -->
    <div id="calibrationModal" class="modal">
        <div class="modal-content" style="width: 360px;">
            <h3>距離入力 (Distance)</h3>
            <p style="margin-bottom: 8px; font-size: 14px; color: #64748b;">点A-点B間の実際の距離(m)を入力してください</p>
            <input type="number" id="calDistanceInput" value="5.0" step="0.1" min="0.1"
                style="width: 100%; margin-bottom: 16px; font-size: 16px; box-sizing: border-box;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="calCancelBtn"
                    style="padding: 6px 12px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">キャンセル</button>
                <button id="calOkBtn"
                    style="padding: 6px 12px; border: none; background: var(--primary-color); color: white; border-radius: 4px; cursor: pointer;">OK</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
</head>

<body>

    <!-- Toolbar -->
    <div id="toolbar">
        <button id="drawBtn" class="icon-btn active" title="描画 (Draw)">
            <span class="material-symbols-rounded">edit</span>
        </button>
        <button id="panBtn" class="icon-btn" title="移動 (Pan)">
            <span class="material-symbols-rounded">pan_tool</span>
        </button>
        <div style="height: 1px; background: rgba(0,0,0,0.1); margin: 4px 0;"></div>

        <button id="toggleVehiclePanelBtn" class="icon-btn" title="車両設定 (Vehicle)">
            <span class="material-symbols-rounded">directions_car</span>
        </button>
        <button id="toggleBgPanelBtn" class="icon-btn" title="背景設定 (Background)">
            <span class="material-symbols-rounded">image</span>
        </button>

        <div style="height: 1px; background: rgba(0,0,0,0.1); margin: 4px 0;"></div>
        <button id="undoBtn" class="icon-btn" title="1つ戻る (Undo)">
            <span class="material-symbols-rounded">undo</span>
        </button>
        <button id="clearBtn" class="icon-btn danger" title="全クリア (Clear)">
            <span class="material-symbols-rounded">delete</span>
        </button>
        <div style="height: 1px; background: rgba(0,0,0,0.1); margin: 4px 0;"></div>
        <button id="exportDxfBtn" class="icon-btn" title="DXFエクスポート (Export)">
            <span class="material-symbols-rounded">download</span>
        </button>
    </div>

    <!-- Vehicle Panel -->
    <div id="vehicle-panel" class="floating-panel">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>車両設定</h2>
            <button id="closeVehiclePanelBtn" class="icon-btn" style="width: 32px; height: 32px;">
                <span class="material-symbols-rounded">close</span>
            </button>
        </div>
        <div class="control-group">
            <label>車両設定</label>
            <select id="vehiclePreset">
                <option value="custom">カスタム</option>
                <!-- Options will be populated by JS -->
            </select>
        </div>
        <div class="control-group">
            <button id="openSettingsBtn"
                style="width: 100%; padding: 8px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer;">車両諸元設定</button>
        </div>
    </div>

    <!-- Background Panel -->
    <div id="background-panel" class="floating-panel">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>背景設定</h2>
            <button id="closeBgPanelBtn" class="icon-btn" style="width: 32px; height: 32px;">
                <span class="material-symbols-rounded">close</span>
            </button>
        </div>
        <div class="control-group">
            <label>背景図面</label>
            <input type="file" id="bgFileInput" accept="image/*,application/pdf">
        </div>
        <div class="control-group">
            <label>不透明度</label>
            <input type="range" id="bgOpacity" min="0" max="1" step="0.1" value="0.5">
        </div>
        <div class="control-group">
            <button id="calibrateBtn"
                style="width: 100%; padding: 8px; background: #64748b; color: white; border: none; border-radius: 6px; cursor: pointer;">尺度調整</button>
            <div id="calibrationStatus" class="hidden"
                style="color: var(--primary-color); font-size: 12px; margin-top: 4px;">
                点Aをクリックしてください...
            </div>
        </div>
    </div>

    <!-- Legend & Instructions -->
    <div class="instructions">
        <div style="font-weight: 600; margin-bottom: 8px;">凡例</div>
        <div class="legend-item">
            <div class="legend-color" style="background:red"></div>トラクター後輪
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background:green"></div>トレーラー後輪
        </div>
        <div class="legend-item">
            <div class="legend-color"
                style="background:blue; border:1px dashed blue; height:0; border-top:2px dashed blue;"></div>車体外郭
        </div>
        <div style="margin-top: 12px; font-weight: 600; margin-bottom: 4px;">操作方法</div>
        <div>1. クリック: 通過点を追加</div>
        <div>2. ドラッグ: 自由に描画</div>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- Vehicle Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>車両諸元設定</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="editor-panel">
                    <h3>プリセット</h3>
                    <select id="modalPreset"
                        style="width: 100%; margin-bottom: 20px; padding: 8px; border-radius: 6px; border: 1px solid #cbd5e1;">
                        <option value="custom">カスタム</option>
                    </select>

                    <h3>トラクター</h3>
                    <table class="params-table">
                        <tr>
                            <td>全幅</td>
                            <td><input type="number" id="m_width" step="0.01"></td>
                            <td class="unit">m</td>
                        </tr>
                        <tr>
                            <td>ホイールベース</td>
                            <td><input type="number" id="m_wheelbase" step="0.01"></td>
                            <td class="unit">m</td>
                        </tr>
                        <tr>
                            <td>Fオーバーハング</td>
                            <td><input type="number" id="m_overhangFront" step="0.01"></td>
                            <td class="unit">m</td>
                        </tr>
                        <tr>
                            <td>Rオーバーハング</td>
                            <td><input type="number" id="m_overhangRear" step="0.01"></td>
                            <td class="unit">m</td>
                        </tr>
                        <tr>
                            <td>最大操舵角</td>
                            <td><input type="number" id="m_maxSteering" step="1"></td>
                            <td class="unit">deg</td>
                        </tr>
                        <tr>
                            <td>後輪軸数</td>
                            <td><input type="number" id="m_tractorAxles" step="1" min="1" value="1"></td>
                            <td class="unit">軸</td>
                        </tr>
                    </table>

                    <h3>トレーラー</h3>
                    <div class="form-row">
                        <label style="width: auto;"><input type="checkbox" id="m_hasTrailer" style="margin-right: 8px;">
                            トレーラー連結</label>
                    </div>
                    <div id="m_trailerParams">
                        <table class="params-table">
                            <tr>
                                <td>全幅</td>
                                <td><input type="number" id="m_trailerWidth" step="0.01"></td>
                                <td class="unit">m</td>
                            </tr>
                            <tr>
                                <td>ホイールベース</td>
                                <td><input type="number" id="m_trailerWheelbase" step="0.01"></td>
                                <td class="unit">m</td>
                            </tr>
                            <tr>
                                <td>Fオーバーハング</td>
                                <td><input type="number" id="m_trailerOverhangFront" step="0.01"></td>
                                <td class="unit">m</td>
                            </tr>
                            <tr>
                                <td>Rオーバーハング</td>
                                <td><input type="number" id="m_trailerOverhangRear" step="0.01"></td>
                                <td class="unit">m</td>
                            </tr>
                            <tr>
                                <td>連結点オフセット</td>
                                <td><input type="number" id="m_hitchOffset" step="0.01"></td>
                                <td class="unit">m</td>
                            </tr>
                            <tr>
                                <td>後輪軸数</td>
                                <td><input type="number" id="m_trailerAxles" step="1" min="1" value="2"></td>
                                <td class="unit">軸</td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="preview-panel">
                    <h3>車両形状図</h3>
                    <canvas id="previewCanvas" width="360" height="480"></canvas>
                    <div style="margin-top: 10px; font-size: 0.85rem; color: #666; text-align: center;">
                        上: 上面図 / 下: 側面図<br>
                        ※ 寸法を変更するとリアルタイムに反映されます
                    </div>
                    <button id="saveSettingsBtn"
                        style="margin-top: 20px; width: 100%; padding: 10px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">設定を適用</button>
                    <button id="cancelSettingsBtn"
                        style="margin-top: 10px; width: 100%; padding: 10px; background: white; color: #64748b; border: 1px solid #cbd5e1; border-radius: 6px; cursor: pointer;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // エラーハンドリング
        // エラーハンドリング
        window.onerror = function (message, source, lineno, colno, error) {
            if (message === 'Script error.') {
                // Ignore generic cross-origin errors
                return;
            }
            console.error(message, source, lineno, colno, error);
            // alert('エラーが発生しました: ' + message); // Disable alert for production
        };

        /* 車両プリセットデータ (推定値含む) */
        const vehiclePresets = [
            {
                id: '2t_truck',
                name: '2tトラック',
                type: 'single',
                params: {
                    wheelbase: 2.5,
                    width: 1.7,
                    overhangFront: 1.0,
                    overhangRear: 1.5,
                    maxSteeringAngle: 35,
                    tractorAxles: 1
                }
            },
            {
                id: '4t_truck',
                name: '4tトラック',
                type: 'single',
                params: {
                    wheelbase: 3.8,
                    width: 2.2,
                    overhangFront: 1.2,
                    overhangRear: 2.2,
                    maxSteeringAngle: 40,
                    tractorAxles: 1
                }
            },
            {
                id: '10t_truck',
                name: '10tトラック',
                type: 'single',
                params: {
                    wheelbase: 5.5,
                    width: 2.5,
                    overhangFront: 1.5,
                    overhangRear: 2.8,
                    maxSteeringAngle: 45,
                    tractorAxles: 2
                }
            },
            {
                id: 'semi_trailer_40ft',
                name: 'セミトレーラー 40ft',
                type: 'trailer',
                params: {
                    wheelbase: 3.5, // トラクター
                    width: 2.5,
                    overhangFront: 1.3,
                    overhangRear: 1.0, // トラクター後部
                    maxSteeringAngle: 45,
                    tractorAxles: 2,
                    // トレーラー部分
                    trailerWheelbase: 8.5, // キングピンから車軸群中心
                    trailerWidth: 2.5,
                    trailerOverhangRear: 2.5,
                    trailerOverhangFront: 0.0,
                    hitchOffset: 0.0, // 後車軸上の場合
                    trailerAxles: 3
                }
            }
        ];

        // --- Classes ---

        class VehicleModel {
            constructor() {
                // 初期値 (2tトラック相当)
                this.wheelbase = 2.5;
                this.width = 1.7;
                this.overhangFront = 1.0;
                this.overhangRear = 1.5;
                this.maxSteeringAngle = 35 * (Math.PI / 180); // Radian
                this.tractorAxles = 1;

                // トレーラー用パラメータ
                this.hasTrailer = false;
                this.trailerWheelbase = 0; // 連結点からトレーラー車軸まで
                this.trailerWidth = 0;
                this.trailerOverhangRear = 0;
                this.trailerOverhangFront = 0;
                this.hitchOffset = 0; // トラクター後車軸からの連結点オフセット（正：後ろ、負：前）
                this.trailerAxles = 2;
            }
        }

        class SimulationEngine {
            constructor() {
                this.stepSize = 0.1;
            }

            transformPoint(lx, ly, wx, wy, heading) {
                return {
                    x: wx + lx * Math.cos(heading) - ly * Math.sin(heading),
                    y: wy + lx * Math.sin(heading) + ly * Math.cos(heading)
                };
            }

            simulate(path, vehicle) {
                if (!path || path.length < 2) return [];

                const states = [];

                let currentPos = { x: path[0].x, y: path[0].y };
                let currentHeading = Math.atan2(path[1].y - path[0].y, path[1].x - path[0].x);

                // トレーラー初期状態（トラクターと一直線と仮定）
                let trailerHeading = currentHeading;
                // 連結点位置
                let hitchPos = {
                    x: currentPos.x - vehicle.hitchOffset * Math.cos(currentHeading),
                    y: currentPos.y - vehicle.hitchOffset * Math.sin(currentHeading)
                };
                // トレーラー車軸位置
                let trailerPos = {
                    x: hitchPos.x - vehicle.trailerWheelbase * Math.cos(trailerHeading),
                    y: hitchPos.y - vehicle.trailerWheelbase * Math.sin(trailerHeading)
                };

                let targetIndex = 1;

                const maxSteps = 10000;
                for (let i = 0; i < maxSteps; i++) {
                    const distToEnd = Math.hypot(path[path.length - 1].x - currentPos.x, path[path.length - 1].y - currentPos.y);
                    if (distToEnd < 0.5) break;

                    // 1. Pure Pursuit
                    const targetPt = path[targetIndex];
                    const distToTarget = Math.hypot(targetPt.x - currentPos.x, targetPt.y - currentPos.y);

                    if (distToTarget < 1.0 && targetIndex < path.length - 1) {
                        targetIndex++;
                    }

                    const angleToTarget = Math.atan2(targetPt.y - currentPos.y, targetPt.x - currentPos.x);
                    let alpha = angleToTarget - currentHeading;
                    while (alpha > Math.PI) alpha -= 2 * Math.PI;
                    while (alpha < -Math.PI) alpha += 2 * Math.PI;

                    // maxSteeringAngle is already in radians in VehicleModel
                    const maxSteerRad = vehicle.maxSteeringAngle;
                    let steeringAngle = Math.atan(2 * vehicle.wheelbase * Math.sin(alpha) / distToTarget);

                    if (steeringAngle > maxSteerRad) steeringAngle = maxSteerRad;
                    if (steeringAngle < -maxSteerRad) steeringAngle = -maxSteerRad;

                    // 2. トラクター移動
                    const dx = this.stepSize * Math.cos(currentHeading);
                    const dy = this.stepSize * Math.sin(currentHeading);
                    const dHeading = (this.stepSize / vehicle.wheelbase) * Math.tan(steeringAngle);

                    const nextPos = { x: currentPos.x + dx, y: currentPos.y + dy };
                    const nextHeading = currentHeading + dHeading;

                    // 3. トレーラー移動
                    let nextTrailerPos = { ...trailerPos };
                    let nextTrailerHeading = trailerHeading;

                    if (vehicle.hasTrailer) {
                        // 新しい連結点位置
                        const nextHitchPos = {
                            x: nextPos.x - vehicle.hitchOffset * Math.cos(nextHeading),
                            y: nextPos.y - vehicle.hitchOffset * Math.sin(nextHeading)
                        };

                        // トレーラーの移動
                        const dxT = nextHitchPos.x - trailerPos.x;
                        const dyT = nextHitchPos.y - trailerPos.y;

                        const desiredHeading = Math.atan2(dyT, dxT);

                        nextTrailerHeading = desiredHeading;
                        nextTrailerPos = {
                            x: nextHitchPos.x - vehicle.trailerWheelbase * Math.cos(nextTrailerHeading),
                            y: nextHitchPos.y - vehicle.trailerWheelbase * Math.sin(nextTrailerHeading)
                        };
                    }

                    // 4. 包絡線（Envelope）計算
                    const trFront = vehicle.wheelbase + vehicle.overhangFront;
                    const trRear = -vehicle.overhangRear;
                    const trHalfW = vehicle.width / 2;

                    const tractorCorners = {
                        fl: this.transformPoint(trFront, trHalfW, currentPos.x, currentPos.y, currentHeading),
                        fr: this.transformPoint(trFront, -trHalfW, currentPos.x, currentPos.y, currentHeading),
                        rl: this.transformPoint(trRear, trHalfW, currentPos.x, currentPos.y, currentHeading),
                        rr: this.transformPoint(trRear, -trHalfW, currentPos.x, currentPos.y, currentHeading)
                    };

                    let trailerCorners = null;
                    if (vehicle.hasTrailer) {
                        const tlFront = vehicle.trailerWheelbase; // 連結点から前方（便宜上）
                        const tlRear = -vehicle.trailerOverhangRear;
                        const tlHalfW = vehicle.trailerWidth / 2;

                        trailerCorners = {
                            fl: this.transformPoint(vehicle.trailerWheelbase, tlHalfW, trailerPos.x, trailerPos.y, trailerHeading),
                            fr: this.transformPoint(vehicle.trailerWheelbase, -tlHalfW, trailerPos.x, trailerPos.y, trailerHeading),
                            rl: this.transformPoint(tlRear, tlHalfW, trailerPos.x, trailerPos.y, trailerHeading),
                            rr: this.transformPoint(tlRear, -tlHalfW, trailerPos.x, trailerPos.y, trailerHeading)
                        };
                    }

                    // 更新
                    currentPos = nextPos;
                    currentHeading = nextHeading;
                    trailerPos = nextTrailerPos;
                    trailerHeading = nextTrailerHeading;

                    states.push({
                        x: currentPos.x,
                        y: currentPos.y,
                        heading: currentHeading,
                        steeringAngle: steeringAngle,
                        trailer: vehicle.hasTrailer ? {
                            x: trailerPos.x,
                            y: trailerPos.y,
                            heading: trailerHeading
                        } : null,
                        envelope: {
                            tractor: tractorCorners,
                            trailer: trailerCorners
                        }
                    });
                }

                return states;
            }
        }

        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.scale = 20;
                this.offsetX = 0;
                this.offsetY = 0;

                // Background
                this.bgImage = null;
                this.bgOpacity = 0.5;
                this.bgX = 0;
                this.bgY = 0;

                // View Transform (Zoom/Pan)
                this.viewScale = 1.0;
                this.viewOffset = { x: 0, y: 0 };
            }

            resize() {
                if (this.canvas.parentElement) {
                    this.width = this.canvas.parentElement.clientWidth;
                    this.height = this.canvas.parentElement.clientHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            setBackground(image) {
                this.bgImage = image;
                // Reset background position to center
                this.bgX = -image.width / 2;
                this.bgY = -image.height / 2;
            }

            toScreen(x, y) {
                // World -> Screen
                // 1. Scale by meters-to-pixels (this.scale)
                // 2. Apply View Zoom (this.viewScale)
                // 3. Apply View Pan (this.viewOffset)
                // 4. Center on screen

                const worldScaledX = x * this.scale;
                const worldScaledY = y * this.scale;

                return {
                    x: (worldScaledX + this.offsetX) * this.viewScale + this.viewOffset.x + this.width / 2,
                    y: (worldScaledY + this.offsetY) * this.viewScale + this.viewOffset.y + this.height / 2
                };
            }

            toWorld(screenX, screenY) {
                // Screen -> World
                // Reverse of toScreen

                const centeredX = screenX - this.width / 2 - this.viewOffset.x;
                const centeredY = screenY - this.height / 2 - this.viewOffset.y;

                const unzoomedX = centeredX / this.viewScale;
                const unzoomedY = centeredY / this.viewScale;

                return {
                    x: (unzoomedX - this.offsetX) / this.scale,
                    y: (unzoomedY - this.offsetY) / this.scale
                };
            }

            zoomAt(screenX, screenY, delta) {
                const zoomIntensity = 0.1;
                const newScale = this.viewScale * (1 + delta * zoomIntensity);

                // Limit zoom
                if (newScale < 0.1 || newScale > 10) return;

                // Calculate mouse position in world coordinates before zoom
                const worldPos = this.toWorld(screenX, screenY);

                this.viewScale = newScale;

                // Adjust offset to keep the world position under the mouse fixed
                // New Screen = (World * scale + offset) * viewScale + viewOffset + Center
                // We want Screen to be constant.
                // Actually, easier logic:
                // MouseWorld should be same before and after.
                // We just updated viewScale. Now we need to update viewOffset.

                // Let's use the toScreen formula:
                // ScreenX = (WorldX * scale + offsetX) * viewScale + viewOffset.x + Width/2
                // viewOffset.x = ScreenX - Width/2 - (WorldX * scale + offsetX) * viewScale

                const worldScaledX = worldPos.x * this.scale;
                const worldScaledY = worldPos.y * this.scale;

                this.viewOffset.x = screenX - this.width / 2 - (worldScaledX + this.offsetX) * this.viewScale;
                this.viewOffset.y = screenY - this.height / 2 - (worldScaledY + this.offsetY) * this.viewScale;
            }

            pan(dx, dy) {
                this.viewOffset.x += dx;
                this.viewOffset.y += dy;
            }

            drawCalibration(currentMousePos) {
                if (!calPoint1) return;

                const p1 = this.toScreen(calPoint1.x, calPoint1.y);

                // Draw Point A
                this.ctx.fillStyle = 'blue';
                this.ctx.beginPath(); this.ctx.arc(p1.x, p1.y, 5, 0, Math.PI * 2); this.ctx.fill();

                // Draw Dynamic Line (Point A to Cursor)
                // Use global currentMousePos if argument is missing, just in case
                const mousePos = currentMousePos || (typeof window !== 'undefined' ? window.currentMousePos : null);

                if (calibrationState === 'point2' && mousePos && !calPoint2) {
                    const p2 = this.toScreen(mousePos.x, mousePos.y);

                    this.ctx.strokeStyle = '#ff00ff'; // Magenta
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    // Cursor Marker
                    this.ctx.beginPath(); this.ctx.arc(p2.x, p2.y, 3, 0, Math.PI * 2); this.ctx.fill();
                }

                // Draw Point B and Fixed Line
                if (calPoint2) {
                    const p2 = this.toScreen(calPoint2.x, calPoint2.y);

                    // Point B
                    this.ctx.fillStyle = 'blue';
                    this.ctx.beginPath(); this.ctx.arc(p2.x, p2.y, 5, 0, Math.PI * 2); this.ctx.fill();

                    // Fixed Line
                    this.ctx.strokeStyle = 'blue';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.stroke();
                }
            }

            drawPath(path, currentMousePos = null) {
                // Draw Background
                if (this.bgImage) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.bgOpacity;

                    const worldW = this.bgImage.width * bgMetersPerPixel;
                    const worldH = this.bgImage.height * bgMetersPerPixel;

                    // Draw centered at (0,0) world
                    const screenTopLeft = this.toScreen(-worldW / 2, -worldH / 2);
                    const screenBottomRight = this.toScreen(worldW / 2, worldH / 2);

                    this.ctx.drawImage(this.bgImage,
                        screenTopLeft.x, screenTopLeft.y,
                        screenBottomRight.x - screenTopLeft.x,
                        screenBottomRight.y - screenTopLeft.y
                    );
                    this.ctx.restore();
                }

                // Draw Calibration Points
                this.drawCalibration(currentMousePos);

                if (path.length < 2 && !calPoint1) return; // Allow drawing background even if no path

                if (path.length >= 2) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = '#aaa';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);

                    const start = this.toScreen(path[0].x, path[0].y);
                    this.ctx.moveTo(start.x, start.y);

                    for (let i = 1; i < path.length; i++) {
                        const p = this.toScreen(path[i].x, path[i].y);
                        this.ctx.lineTo(p.x, p.y);
                    }

                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    this.ctx.fillStyle = '#666';
                    for (const pt of path) {
                        const p = this.toScreen(pt.x, pt.y);
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            drawSimulation(states, vehicle) {
                if (!states || states.length === 0) return;

                // 0. Swept Path (包絡線) - 青い破線
                this.ctx.strokeStyle = 'blue';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([3, 3]);

                this.drawEnvelopeLine(states, s => s.envelope.tractor.fl);
                this.drawEnvelopeLine(states, s => s.envelope.tractor.fr);

                if (vehicle.hasTrailer) {
                    // トレーラーの左後・右後
                    this.drawEnvelopeLine(states, s => s.envelope.trailer.rl);
                    this.drawEnvelopeLine(states, s => s.envelope.trailer.rr);
                } else {
                    // 単車の場合はトラクターの後ろも描く
                    this.drawEnvelopeLine(states, s => s.envelope.tractor.rl);
                    this.drawEnvelopeLine(states, s => s.envelope.tractor.rr);
                }

                this.ctx.setLineDash([]);

                // 1. トラクター後輪軌跡
                this.ctx.beginPath();
                this.ctx.strokeStyle = 'red';
                this.ctx.lineWidth = 2;
                const start = this.toScreen(states[0].x, states[0].y);
                this.ctx.moveTo(start.x, start.y);
                for (let i = 1; i < states.length; i++) {
                    const p = this.toScreen(states[i].x, states[i].y);
                    this.ctx.lineTo(p.x, p.y);
                }
                this.ctx.stroke();

                // 2. トレーラー後輪軌跡
                if (vehicle.hasTrailer) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'green';
                    this.ctx.lineWidth = 2;
                    const tStart = this.toScreen(states[0].trailer.x, states[0].trailer.y);
                    this.ctx.moveTo(tStart.x, tStart.y);
                    for (let i = 1; i < states.length; i++) {
                        const p = this.toScreen(states[i].trailer.x, states[i].trailer.y);
                        this.ctx.lineTo(p.x, p.y);
                    }
                    this.ctx.stroke();
                }

                // 3. 車両描画
                const step = Math.floor(states.length / 10) || 1;
                for (let i = 0; i < states.length; i += step) {
                    this.drawVehicleBody(states[i], vehicle, i === states.length - 1);
                }
                this.drawVehicleBody(states[states.length - 1], vehicle, true);
            }

            drawEnvelopeLine(states, selector) {
                this.ctx.beginPath();
                const start = this.toScreen(selector(states[0]).x, selector(states[0]).y);
                this.ctx.moveTo(start.x, start.y);
                for (let i = 1; i < states.length; i++) {
                    const pt = selector(states[i]);
                    const p = this.toScreen(pt.x, pt.y);
                    this.ctx.lineTo(p.x, p.y);
                }
                this.ctx.stroke();
            }

            drawVehicleBody(state, vehicle, isLast) {
                // Effective scale (Base scale * Zoom)
                const s = this.scale * this.viewScale;

                // --- トラクター ---
                const { x, y, heading } = state;
                const screenPos = this.toScreen(x, y);

                this.ctx.save();
                this.ctx.translate(screenPos.x, screenPos.y);
                this.ctx.rotate(heading);

                const lenFront = vehicle.wheelbase + vehicle.overhangFront;
                const lenRear = vehicle.overhangRear;
                const halfWidth = vehicle.width / 2;

                this.ctx.fillStyle = isLast ? 'rgba(0, 123, 255, 0.5)' : 'rgba(0, 123, 255, 0.1)';
                this.ctx.strokeStyle = isLast ? '#0056b3' : 'rgba(0, 86, 179, 0.3)';
                this.ctx.lineWidth = 1; // Line width can remain constant or scale if desired

                // 車体
                this.ctx.beginPath();
                this.ctx.rect(-lenRear * s, -halfWidth * s, (lenFront + lenRear) * s, vehicle.width * s);
                this.ctx.fill();
                this.ctx.stroke();

                // 車軸
                this.ctx.beginPath();
                this.ctx.strokeStyle = 'black';
                this.ctx.moveTo(0, -halfWidth * s);
                this.ctx.lineTo(0, halfWidth * s);
                this.ctx.stroke();
                this.ctx.moveTo(vehicle.wheelbase * s, -halfWidth * s);
                this.ctx.lineTo(vehicle.wheelbase * s, halfWidth * s);
                this.ctx.stroke();

                this.ctx.restore();

                // --- トレーラー ---
                if (vehicle.hasTrailer && state.trailer) {
                    const tx = state.trailer.x;
                    const ty = state.trailer.y;
                    const th = state.trailer.heading;
                    const tScreenPos = this.toScreen(tx, ty);

                    this.ctx.save();
                    this.ctx.translate(tScreenPos.x, tScreenPos.y);
                    this.ctx.rotate(th);

                    const tLenFront = vehicle.trailerWheelbase;
                    const tLenRear = vehicle.trailerOverhangRear;
                    const tHalfWidth = vehicle.trailerWidth / 2;

                    this.ctx.fillStyle = isLast ? 'rgba(40, 167, 69, 0.5)' : 'rgba(40, 167, 69, 0.1)';
                    this.ctx.strokeStyle = isLast ? '#1e7e34' : 'rgba(40, 167, 69, 0.3)';

                    // 車体
                    this.ctx.beginPath();
                    this.ctx.rect(-tLenRear * s, -tHalfWidth * s, (tLenFront + tLenRear) * s, vehicle.trailerWidth * s);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // 車軸
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'black';
                    this.ctx.moveTo(0, -tHalfWidth * s);
                    this.ctx.lineTo(0, tHalfWidth * s);

                    this.ctx.stroke();

                    this.ctx.restore();
                }
            }
        }

        // Global Variables for Calibration (accessible by Renderer)
        let calibrationState = 'none'; // 'none', 'point1', 'point2'
        let calPoint1 = null;
        let calPoint2 = null;
        let currentMousePos = null;

        // --- Main Logic ---

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mainCanvas');
            const renderer = new Renderer(canvas);
            const vehicle = new VehicleModel();
            const engine = new SimulationEngine();

            let path = [];
            let isDrawing = false;

            // Background & Calibration Globals
            let bgImageElement = null;
            let bgMetersPerPixel = 0.05; // Default

            const inputs = {
                // Toolbar
                toggleVehiclePanelBtn: document.getElementById('toggleVehiclePanelBtn'),
                toggleBgPanelBtn: document.getElementById('toggleBgPanelBtn'),
                undoBtn: document.getElementById('undoBtn'),
                clearBtn: document.getElementById('clearBtn'),
                exportDxfBtn: document.getElementById('exportDxfBtn'),

                // Panels
                vehiclePanel: document.getElementById('vehicle-panel'),
                backgroundPanel: document.getElementById('background-panel'),
                closeVehiclePanelBtn: document.getElementById('closeVehiclePanelBtn'),
                closeBgPanelBtn: document.getElementById('closeBgPanelBtn'),

                // Controls
                vehiclePreset: document.getElementById('vehiclePreset'),
                openSettingsBtn: document.getElementById('openSettingsBtn'),
                bgFileInput: document.getElementById('bgFileInput'),
                bgOpacity: document.getElementById('bgOpacity'),
                calibrateBtn: document.getElementById('calibrateBtn'),
                calibrationStatus: document.getElementById('calibrationStatus'),

                // Modal
                settingsModal: document.getElementById('settingsModal'),
                closeModalBtn: document.querySelector('.close'),
                saveSettingsBtn: document.getElementById('saveSettingsBtn'),
                cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),

                // Modal Inputs
                m_width: document.getElementById('m_width'),
                m_wheelbase: document.getElementById('m_wheelbase'),
                m_overhangFront: document.getElementById('m_overhangFront'),
                m_overhangRear: document.getElementById('m_overhangRear'),
                m_maxSteering: document.getElementById('m_maxSteering'),
                m_tractorAxles: document.getElementById('m_tractorAxles'),

                m_hasTrailer: document.getElementById('m_hasTrailer'),
                m_trailerWheelbase: document.getElementById('m_trailerWheelbase'),
                m_trailerWidth: document.getElementById('m_trailerWidth'),
                m_trailerOverhangRear: document.getElementById('m_trailerOverhangRear'),
                m_trailerOverhangFront: document.getElementById('m_trailerOverhangFront'),
                m_hitchOffset: document.getElementById('m_hitchOffset'),
                m_trailerAxles: document.getElementById('m_trailerAxles'),
                m_trailerParams: document.getElementById('m_trailerParams'),

                modalPreset: document.getElementById('modalPreset'),

                // Calibration Modal
                calibrationModal: document.getElementById('calibrationModal'),
                calDistanceInput: document.getElementById('calDistanceInput'),
                calOkBtn: document.getElementById('calOkBtn'),
                calCancelBtn: document.getElementById('calCancelBtn'),
            };

            // Toggle Panels
            function togglePanel(panel, btn) {
                const isHidden = panel.style.display === 'none' || panel.style.display === '';
                // Close all
                inputs.vehiclePanel.style.display = 'none';
                inputs.backgroundPanel.style.display = 'none';
                inputs.toggleVehiclePanelBtn.classList.remove('active');
                inputs.toggleBgPanelBtn.classList.remove('active');

                if (isHidden) {
                    panel.style.display = 'block';
                    btn.classList.add('active');
                }
            }

            inputs.toggleVehiclePanelBtn.addEventListener('click', () => {
                togglePanel(inputs.vehiclePanel, inputs.toggleVehiclePanelBtn);
            });

            inputs.toggleBgPanelBtn.addEventListener('click', () => {
                togglePanel(inputs.backgroundPanel, inputs.toggleBgPanelBtn);
            });

            inputs.closeVehiclePanelBtn.addEventListener('click', () => {
                inputs.vehiclePanel.style.display = 'none';
                inputs.toggleVehiclePanelBtn.classList.remove('active');
            });

            inputs.closeBgPanelBtn.addEventListener('click', () => {
                inputs.backgroundPanel.style.display = 'none';
                inputs.toggleBgPanelBtn.classList.remove('active');
            });

            // --- Calibration Modal Logic ---
            let tempDistImagePixels = 0;

            inputs.calOkBtn.addEventListener('click', () => {
                const realDist = parseFloat(inputs.calDistanceInput.value);
                if (realDist > 0 && tempDistImagePixels > 0) {
                    bgMetersPerPixel = realDist / tempDistImagePixels;
                    alert(`尺度を調整しました(Scale updated): 1px = ${bgMetersPerPixel.toFixed(4)} m`);
                    closeCalibrationModal();
                } else {
                    alert("有効な数値を入力してください (Invalid number)");
                }
            });

            inputs.calCancelBtn.addEventListener('click', () => {
                closeCalibrationModal();
            });

            function closeCalibrationModal() {
                inputs.calibrationModal.style.display = 'none';
                calibrationState = 'none';
                calPoint1 = null;
                calPoint2 = null;
                inputs.calibrationStatus.classList.add('hidden');

                // Restore cursor based on mode
                setMode(interactionMode);

                update();
            }

            // --- Background & Calibration Logic ---

            inputs.bgFileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (file.type === 'application/pdf') {
                    const fileReader = new FileReader();
                    fileReader.onload = async function () {
                        const typedarray = new Uint8Array(this.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 2.0 }); // High res

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;

                        bgImageElement = new Image();
                        bgImageElement.onload = () => {
                            renderer.setBackground(bgImageElement);
                            bgMetersPerPixel = 0.05;
                            update();
                        };
                        bgImageElement.src = canvas.toDataURL();
                    };
                    fileReader.readAsArrayBuffer(file);
                } else {
                    const fileReader = new FileReader();
                    fileReader.onload = function (e) {
                        bgImageElement = new Image();
                        bgImageElement.onload = () => {
                            renderer.setBackground(bgImageElement);
                            bgMetersPerPixel = 0.05;
                            update();
                        };
                        bgImageElement.src = e.target.result;
                    };
                    fileReader.readAsDataURL(file);
                }
            });

            inputs.bgOpacity.addEventListener('input', (e) => {
                renderer.bgOpacity = parseFloat(e.target.value);
                update();
            });

            inputs.calibrateBtn.addEventListener('click', () => {
                try {
                    console.log("Calibrate button clicked");
                    if (!bgImageElement) {
                        alert('先に背景画像を読み込んでください (Please load a background first)');
                        return;
                    }
                    calibrationState = 'point1';
                    loadModalValues();
                    drawPreview();
                    inputs.calibrationStatus.classList.remove('hidden');
                    inputs.calibrationStatus.textContent = "図面上の点Aをクリックしてください (1/2)";
                    canvas.style.cursor = 'default'; // Use arrow cursor for calibration
                } catch (e) {
                    alert("Calibrate Error: " + e.message);
                    console.error(e);
                }
            });

            // Override Renderer drawPath to support custom image scaling and rubber-band UI
            renderer.drawPath = function (path, currentMousePos) {
                // Draw Background
                if (this.bgImage) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.bgOpacity;

                    const worldW = this.bgImage.width * bgMetersPerPixel;
                    const worldH = this.bgImage.height * bgMetersPerPixel;

                    // Draw centered at (0,0) world
                    const screenTopLeft = this.toScreen(-worldW / 2, -worldH / 2);
                    const screenBottomRight = this.toScreen(worldW / 2, worldH / 2);

                    this.ctx.drawImage(this.bgImage,
                        screenTopLeft.x, screenTopLeft.y,
                        screenBottomRight.x - screenTopLeft.x,
                        screenBottomRight.y - screenTopLeft.y
                    );

                    this.ctx.restore();
                }

                // Draw Calibration Points
                if (calPoint1) {
                    const p1 = this.toScreen(calPoint1.x, calPoint1.y);
                    this.ctx.fillStyle = 'blue';
                    this.ctx.beginPath(); this.ctx.arc(p1.x, p1.y, 5, 0, Math.PI * 2); this.ctx.fill();
                }
                if (calPoint2) {
                    const p2 = this.toScreen(calPoint2.x, calPoint2.y);
                    this.ctx.fillStyle = 'blue';
                    this.ctx.beginPath(); this.ctx.arc(p2.x, p2.y, 5, 0, Math.PI * 2); this.ctx.fill();

                    // Line
                    if (calPoint1) {
                        const p1 = this.toScreen(calPoint1.x, calPoint1.y);
                        this.ctx.strokeStyle = 'blue';
                        this.ctx.beginPath(); this.ctx.moveTo(p1.x, p1.y); this.ctx.lineTo(p2.x, p2.y); this.ctx.stroke();
                    }
                }

                if (path.length < 2 && !calPoint1 && !currentMousePos) return; // Allow drawing background even if no path

                // Draw existing path
                if (path.length >= 1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = '#aaa';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);

                    const start = this.toScreen(path[0].x, path[0].y);
                    this.ctx.moveTo(start.x, start.y);

                    for (let i = 1; i < path.length; i++) {
                        const p = this.toScreen(path[i].x, path[i].y);
                        this.ctx.lineTo(p.x, p.y);
                    }

                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    this.ctx.fillStyle = '#666';
                    for (const pt of path) {
                        const p = this.toScreen(pt.x, pt.y);
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // Draw Rubber-band line (Preview next segment)
                if (path.length > 0 && currentMousePos) {
                    const lastPt = path[path.length - 1];
                    const pLast = this.toScreen(lastPt.x, lastPt.y);
                    const pCurr = this.toScreen(currentMousePos.x, currentMousePos.y);

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = '#666'; // Preview line color
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([2, 2]); // Finer dash for preview

                    this.ctx.moveTo(pLast.x, pLast.y);
                    this.ctx.lineTo(pCurr.x, pCurr.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            };

            // --- Event Listeners ---

            // Canvas Interaction
            // (Listeners are defined below in startDrawing/draw/stopDrawing)

            function startDrawing(e) {
                // Calibration Logic (Priority)
                if (calibrationState === 'point1') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    calPoint1 = renderer.toWorld(x, y);

                    calibrationState = 'point2';
                    inputs.calibrationStatus.textContent = '点Bをクリックしてください (Click Point B)';
                    update();
                    return;
                }

                if (calibrationState === 'point2') {
                    try {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        calPoint2 = renderer.toWorld(x, y);

                        if (!calPoint1) {
                            calibrationState = 'point1';
                            inputs.calibrationStatus.textContent = '点Aをクリックしてください (1/2)';
                            update();
                            return;
                        }

                        const distWorld = Math.hypot(calPoint2.x - calPoint1.x, calPoint2.y - calPoint1.y);
                        tempDistImagePixels = distWorld / bgMetersPerPixel;

                        // Show Modal
                        inputs.calibrationModal.style.display = 'block';
                        inputs.calDistanceInput.focus();

                        update(); // Show point B
                    } catch (err) {
                        console.error(err);
                        calibrationState = 'none';
                        update();
                    }
                    return;
                }

                // Pan Mode Logic
                if (interactionMode === 'pan') {
                    isPanning = true;
                    lastPanPos = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                    return;
                }

                // Normal Drawing Logic
                if (calibrationState !== 'none') return;

                isDrawing = true;
                addPoint(e);
            }

            function loadModalValues() {
                inputs.m_width.value = vehicle.width;
                inputs.m_wheelbase.value = vehicle.wheelbase;
                inputs.m_overhangFront.value = vehicle.overhangFront;
                inputs.m_overhangRear.value = vehicle.overhangRear;
                inputs.m_maxSteering.value = (vehicle.maxSteeringAngle * 180 / Math.PI).toFixed(0);
                inputs.m_tractorAxles.value = vehicle.tractorAxles || 1;

                inputs.m_hasTrailer.checked = vehicle.hasTrailer;
                inputs.m_trailerWidth.value = vehicle.trailerWidth;
                inputs.m_trailerWheelbase.value = vehicle.trailerWheelbase;
                inputs.m_trailerOverhangFront.value = vehicle.trailerOverhangFront || 0;
                inputs.m_trailerOverhangRear.value = vehicle.trailerOverhangRear;
                inputs.m_hitchOffset.value = vehicle.hitchOffset;
                inputs.m_trailerAxles.value = vehicle.trailerAxles || 2;

                // toggleModalTrailer is defined below
                if (typeof toggleModalTrailer === 'function') {
                    toggleModalTrailer();
                } else {
                    // Fallback if not yet defined (though it should be hoisted or defined below)
                    inputs.m_trailerParams.style.display = inputs.m_hasTrailer.checked ? 'block' : 'none';
                }
            }

            // Duplicate listeners and helpers removed

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            // Buttons
            inputs.undoBtn.addEventListener('click', () => {
                if (path.length > 0) {
                    path.pop();
                    draw();
                }
            });

            inputs.clearBtn.addEventListener('click', () => {
                if (confirm("全消去しますか？")) {
                    path = [];
                    draw();
                }
            });

            inputs.closeModalBtn.addEventListener('click', () => {
                inputs.settingsModal.style.display = 'none';
            });
            window.addEventListener('click', (e) => {
                if (e.target == inputs.settingsModal) {
                    inputs.settingsModal.style.display = 'none';
                }
            });

            // Populate Modal Preset
            vehiclePresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                inputs.modalPreset.appendChild(option);
            });

            inputs.modalPreset.addEventListener('change', (e) => {
                const selectedId = e.target.value;
                if (selectedId === 'custom') return;
                const preset = vehiclePresets.find(p => p.id === selectedId);
                if (preset) applyModalPreset(preset);
            });

            function applyModalPreset(preset) {
                const p = preset.params;
                inputs.m_width.value = p.width;
                inputs.m_wheelbase.value = p.wheelbase;
                inputs.m_overhangFront.value = p.overhangFront;
                inputs.m_overhangRear.value = p.overhangRear;
                inputs.m_maxSteering.value = p.maxSteeringAngle;
                inputs.m_tractorAxles.value = p.tractorAxles || 1;

                inputs.m_hasTrailer.checked = (preset.type === 'trailer');
                if (preset.type === 'trailer') {
                    inputs.m_trailerWidth.value = p.trailerWidth;
                    inputs.m_trailerWheelbase.value = p.trailerWheelbase;
                    inputs.m_trailerOverhangFront.value = p.trailerOverhangFront || 0;
                    inputs.m_trailerOverhangRear.value = p.trailerOverhangRear;
                    inputs.m_hitchOffset.value = p.hitchOffset || 0;
                    inputs.m_trailerAxles.value = p.trailerAxles || 2;
                }
                toggleModalTrailer();
                drawPreview();
            }


            function saveModalValues() {
                vehicle.width = parseFloat(inputs.m_width.value);
                vehicle.wheelbase = parseFloat(inputs.m_wheelbase.value);
                vehicle.overhangFront = parseFloat(inputs.m_overhangFront.value);
                vehicle.overhangRear = parseFloat(inputs.m_overhangRear.value);
                vehicle.maxSteeringAngle = parseFloat(inputs.m_maxSteering.value) * Math.PI / 180;
                vehicle.tractorAxles = parseInt(inputs.m_tractorAxles.value);

                vehicle.hasTrailer = inputs.m_hasTrailer.checked;
                vehicle.trailerWidth = parseFloat(inputs.m_trailerWidth.value);
                vehicle.trailerWheelbase = parseFloat(inputs.m_trailerWheelbase.value);
                vehicle.trailerOverhangFront = parseFloat(inputs.m_trailerOverhangFront.value);
                vehicle.trailerOverhangRear = parseFloat(inputs.m_trailerOverhangRear.value);
                vehicle.hitchOffset = parseFloat(inputs.m_hitchOffset.value);
                vehicle.trailerAxles = parseInt(inputs.m_trailerAxles.value);

                inputs.settingsModal.style.display = 'none';
                update();
            }

            inputs.saveSettingsBtn.addEventListener('click', saveModalValues);
            inputs.cancelSettingsBtn.addEventListener('click', () => {
                inputs.settingsModal.style.display = 'none';
            });

            inputs.m_hasTrailer.addEventListener('change', toggleModalTrailer);
            function toggleModalTrailer() {
                inputs.m_trailerParams.style.display = inputs.m_hasTrailer.checked ? 'block' : 'none';
                drawPreview();
            }

            // Preview Canvas Logic
            const previewCanvas = document.getElementById('previewCanvas');
            const pCtx = previewCanvas.getContext('2d');

            // Listen to all inputs to update preview
            const allInputs = [
                inputs.m_width, inputs.m_wheelbase, inputs.m_overhangFront, inputs.m_overhangRear,
                inputs.m_maxSteering, inputs.m_tractorAxles,
                inputs.m_hasTrailer, inputs.m_trailerWidth, inputs.m_trailerWheelbase,
                inputs.m_trailerOverhangFront, inputs.m_trailerOverhangRear, inputs.m_hitchOffset,
                inputs.m_trailerAxles
            ];
            allInputs.forEach(input => {
                if (input) {
                    input.addEventListener('input', drawPreview);
                    input.addEventListener('change', drawPreview);
                }
            });

            function drawPreview() {
                // Resize
                previewCanvas.width = previewCanvas.clientWidth;
                previewCanvas.height = previewCanvas.clientHeight;
                const w = previewCanvas.width;
                const h = previewCanvas.height;
                pCtx.clearRect(0, 0, w, h);

                // Split canvas: Top half for Top View, Bottom half for Side View
                const halfH = h / 2;

                // Draw Separator
                pCtx.strokeStyle = '#eee';
                pCtx.beginPath();
                pCtx.moveTo(0, halfH);
                pCtx.lineTo(w, halfH);
                pCtx.stroke();

                // --- Shared Calculations ---
                const wb = parseFloat(inputs.m_wheelbase.value) || 0;
                const ohF = parseFloat(inputs.m_overhangFront.value) || 0;
                const ohR = parseFloat(inputs.m_overhangRear.value) || 0;
                const width = parseFloat(inputs.m_width.value) || 0;
                const trAxles = parseInt(inputs.m_tractorAxles.value) || 1;

                let totalLen = wb + ohF + ohR;
                let totalWidth = width;

                let tWb = 0, tOhR = 0, tOhF = 0, hitch = 0, tWidth = 0, tAxles = 1;
                if (inputs.m_hasTrailer.checked) {
                    tWb = parseFloat(inputs.m_trailerWheelbase.value) || 0;
                    tOhR = parseFloat(inputs.m_trailerOverhangRear.value) || 0;
                    tOhF = parseFloat(inputs.m_trailerOverhangFront.value) || 0;
                    hitch = parseFloat(inputs.m_hitchOffset.value) || 0;
                    tWidth = parseFloat(inputs.m_trailerWidth.value) || 0;
                    tAxles = parseInt(inputs.m_trailerAxles.value) || 1;

                    const maxFront = Math.max(wb + ohF, hitch + tOhF);
                    const minRear = Math.min(-ohR, hitch - tWb - tOhR);
                    totalLen = maxFront - minRear;
                    totalWidth = Math.max(totalWidth, tWidth);
                }

                // Add margins
                const margin = 30;

                // --- Top View (Upper Half) ---
                // Center in upper half
                const cxTop = w / 2;
                const cyTop = halfH / 2;

                // Scale for Top View
                let scaleX = (w - margin * 2) / (totalLen || 1);
                let scaleY = (halfH - margin * 2) / (totalWidth || 1);
                const scaleTop = Math.min(scaleX, scaleY, 30);

                // --- Side View (Lower Half) ---
                // Center in lower half
                const cxSide = w / 2;
                const cySide = halfH + halfH / 2;

                // Scale for Side View (Height ~ 3.5m)
                let scaleYSide = (halfH - margin * 2) / 4.0;
                const scaleSide = Math.min(scaleX, scaleYSide, 30);

                // Use same scale for consistency if possible, or independent?
                // Independent is better to maximize usage of space, but might be confusing.
                // Let's use independent scales but keep X aligned? No, centering is better.

                // Calculate Bounding Box Center X
                let minX = -ohR;
                let maxX = wb + ohF;
                if (inputs.m_hasTrailer.checked) {
                    minX = Math.min(minX, hitch - tWb - tOhR);
                    maxX = Math.max(maxX, hitch + tOhF);
                }
                const midX = (minX + maxX) / 2;

                // --- Draw Top View ---
                pCtx.save();
                pCtx.translate(cxTop, cyTop);
                pCtx.scale(scaleTop, scaleTop);
                pCtx.translate(-midX, 0); // Center horizontally
                pCtx.lineWidth = 2 / scaleTop;

                drawVehicleTop(pCtx, wb, ohF, ohR, width, trAxles, tWb, tOhR, tOhF, hitch, tWidth, tAxles, scaleTop);
                pCtx.restore();

                // --- Draw Side View ---
                pCtx.save();
                pCtx.translate(cxSide, cySide + (scaleSide * 1.5)); // Shift down to put ground lower
                pCtx.scale(scaleSide, -scaleSide); // Y up
                pCtx.translate(-midX, 0);
                pCtx.lineWidth = 2 / scaleSide;

                drawVehicleSide(pCtx, wb, ohF, ohR, width, trAxles, tWb, tOhR, tOhF, hitch, tWidth, tAxles, scaleSide);
                pCtx.restore();
            }

            function drawVehicleTop(ctx, wb, ohF, ohR, width, trAxles, tWb, tOhR, tOhF, hitch, tWidth, tAxles, scale) {
                // Tractor Body
                ctx.strokeStyle = '#333';
                ctx.strokeRect(-ohR, -width / 2, wb + ohF + ohR, width);

                // Tractor Wheels
                ctx.fillStyle = '#000';
                const wheelW = 0.2;
                const wheelL = 0.6;

                // Front Axle
                ctx.fillRect(wb - wheelL / 2, width / 2 - wheelW, wheelL, wheelW);
                ctx.fillRect(wb - wheelL / 2, -width / 2, wheelL, wheelW);

                // Rear Axles (Centered on 0)
                drawAxleGroup(ctx, 0, width, trAxles, wheelL, wheelW);

                // Dimensions
                const dimOffset = 1.5;
                drawDim(ctx, 0, -width / 2, wb, -width / 2, wb.toFixed(2), -dimOffset); // Wheelbase (Top)
                drawDim(ctx, wb, -width / 2, wb + ohF, -width / 2, ohF.toFixed(2), -dimOffset); // Front OH (Top)
                drawDim(ctx, -ohR, -width / 2, 0, -width / 2, ohR.toFixed(2), -dimOffset); // Rear OH (Top)
                drawDim(ctx, wb + ohF, width / 2, wb + ohF, -width / 2, width.toFixed(2), dimOffset); // Width (Right)

                // Trailer
                if (inputs.m_hasTrailer.checked) {
                    const hitchX = hitch;
                    const axleX = hitchX - tWb;
                    const frontX = hitchX + tOhF;
                    const rearX = axleX - tOhR;

                    // Body
                    ctx.strokeStyle = '#555';
                    ctx.strokeRect(rearX, -tWidth / 2, frontX - rearX, tWidth);

                    // Hitch
                    ctx.fillStyle = 'red';
                    ctx.beginPath(); ctx.arc(hitchX, 0, 0.1, 0, Math.PI * 2); ctx.fill();

                    // Trailer Axles
                    drawAxleGroup(ctx, axleX, tWidth, tAxles, wheelL, wheelW);

                    // Dimensions
                    const tDimOffset = 1.5;
                    drawDim(ctx, axleX, tWidth / 2, hitchX, tWidth / 2, tWb.toFixed(2), tDimOffset); // Trailer WB (Bottom)
                    drawDim(ctx, rearX, tWidth / 2, axleX, tWidth / 2, tOhR.toFixed(2), tDimOffset); // Trailer Rear OH (Bottom)
                    drawDim(ctx, rearX, tWidth / 2, rearX, -tWidth / 2, tWidth.toFixed(2), -tDimOffset); // Trailer Width (Left)
                }
            }

            function drawVehicleSide(ctx, wb, ohF, ohR, width, trAxles, tWb, tOhR, tOhF, hitch, tWidth, tAxles, scale) {
                const cabH = 2.8;
                const chassisH = 1.0;
                const wheelR = 0.5;

                // Tractor
                // Chassis
                ctx.strokeStyle = '#333';
                ctx.strokeRect(-ohR, 0.4, wb + ohF + ohR, chassisH - 0.4);
                // Cab
                ctx.strokeRect(wb - 0.5, chassisH, ohF + 0.5, cabH - chassisH);

                // Wheels
                ctx.fillStyle = '#333';
                // Front
                ctx.beginPath(); ctx.arc(wb, wheelR, wheelR, 0, Math.PI * 2); ctx.fill();
                // Rear
                drawAxleGroupSide(ctx, 0, trAxles, wheelR);

                // Trailer
                if (inputs.m_hasTrailer.checked) {
                    const hitchX = hitch;
                    const axleX = hitchX - tWb;
                    const frontX = hitchX + tOhF;
                    const rearX = axleX - tOhR;
                    const bedH = 1.3;

                    ctx.strokeStyle = '#555';
                    // Bed
                    ctx.beginPath();
                    ctx.moveTo(rearX, bedH);
                    ctx.lineTo(frontX, bedH);
                    ctx.lineTo(hitchX, 1.1); // Hitch point
                    ctx.stroke();

                    // Axles
                    drawAxleGroupSide(ctx, axleX, tAxles, wheelR);
                }
            }

            function drawAxleGroup(ctx, centerX, width, count, wL, wW) {
                const spacing = 1.2; // 1.2m spacing
                const startX = centerX + (count - 1) * spacing / 2;

                for (let i = 0; i < count; i++) {
                    const x = startX - i * spacing;
                    ctx.fillRect(x - wL / 2, width / 2 - wW, wL, wW);
                    ctx.fillRect(x - wL / 2, -width / 2, wL, wW);
                }
            }

            function drawAxleGroupSide(ctx, centerX, count, radius) {
                const spacing = 1.2;
                const startX = centerX + (count - 1) * spacing / 2;

                for (let i = 0; i < count; i++) {
                    const x = startX - i * spacing;
                    ctx.beginPath(); ctx.arc(x, radius, radius, 0, Math.PI * 2); ctx.fill();
                }
            }

            function drawDim(ctx, x1, y1, x2, y2, text, offset = 0) {
                ctx.save();
                ctx.strokeStyle = '#666';
                ctx.fillStyle = '#666';
                const t = ctx.getTransform();
                const scale = Math.sqrt(t.a * t.a + t.b * t.b); // Extract scale
                ctx.lineWidth = 1 / scale;
                const fontScale = 1 / scale;
                ctx.font = `${12 * fontScale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // Calculate perpendicular vector for offset
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) { ctx.restore(); return; }

                const nx = -dy / len;
                const ny = dx / len;

                // Offset points
                const ox1 = x1 + nx * offset;
                const oy1 = y1 + ny * offset;
                const ox2 = x2 + nx * offset;
                const oy2 = y2 + ny * offset;

                // Extension Lines (Leaders)
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(ox1 + nx * (0.2 * Math.sign(offset) || 0.2), oy1 + ny * (0.2 * Math.sign(offset) || 0.2)); // Extend slightly past dim line
                ctx.moveTo(x2, y2);
                ctx.lineTo(ox2 + nx * (0.2 * Math.sign(offset) || 0.2), oy2 + ny * (0.2 * Math.sign(offset) || 0.2));
                ctx.stroke();

                // Dimension Line
                ctx.beginPath();
                ctx.moveTo(ox1, oy1);
                ctx.lineTo(ox2, oy2);
                ctx.stroke();

                // Ends (Ticks/Arrows)
                const tickSize = 0.1;
                // Draw small ticks at 45 degrees or dots
                ctx.beginPath(); ctx.arc(ox1, oy1, tickSize / 2, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(ox2, oy2, tickSize / 2, 0, Math.PI * 2); ctx.fill();

                // Text
                const mx = (ox1 + ox2) / 2;
                const my = (oy1 + oy2) / 2;

                // Rotate text to align with line? 
                // For simplicity, keep horizontal but offset correctly
                // Or rotate if vertical

                // Simple text placement for now: slightly above the line
                // Adjust text baseline based on offset direction
                ctx.save();
                ctx.translate(mx, my);
                // Rotate text if line is vertical-ish
                const angle = Math.atan2(dy, dx);
                if (Math.abs(angle) > Math.PI / 4 && Math.abs(angle) < 3 * Math.PI / 4) {
                    ctx.rotate(angle - Math.PI / 2); // Rotate to be vertical
                }

                ctx.fillText(text, 0, -0.2 * Math.sign(offset || 1));
                ctx.restore();

                ctx.restore();
            }


            // Sidebar Preset Logic
            vehiclePresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                inputs.vehiclePreset.appendChild(option);
            });

            inputs.vehiclePreset.addEventListener('change', (e) => {
                const selectedId = e.target.value;
                if (selectedId === 'custom') return;
                const preset = vehiclePresets.find(p => p.id === selectedId);
                if (preset) {
                    // Update model directly
                    vehicle.wheelbase = preset.params.wheelbase;
                    vehicle.width = preset.params.width;
                    vehicle.overhangFront = preset.params.overhangFront;
                    vehicle.overhangRear = preset.params.overhangRear;
                    vehicle.maxSteeringAngle = preset.params.maxSteeringAngle * Math.PI / 180;

                    if (preset.type === 'trailer') {
                        vehicle.hasTrailer = true;
                        vehicle.trailerWheelbase = preset.params.trailerWheelbase;
                        vehicle.trailerWidth = preset.params.trailerWidth;
                        vehicle.trailerOverhangRear = preset.params.trailerOverhangRear;
                        vehicle.trailerOverhangFront = preset.params.trailerOverhangFront || 0;
                        vehicle.hitchOffset = preset.params.hitchOffset || 0;
                    } else {
                        vehicle.hasTrailer = false;
                    }
                    update();
                }
            });

            inputs.openSettingsBtn.addEventListener('click', () => {
                inputs.settingsModal.style.display = 'block';
                loadModalValues();
                // Delay drawing to ensure modal is rendered and canvas has size
                setTimeout(() => {
                    drawPreview();
                }, 50);
            });

            function updateInputDisplay() {
                // Sidebar inputs were removed/simplified
            }

            window.addEventListener('resize', () => {
                renderer.resize();
                update();
            });
            renderer.resize();

            // Event Listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Zoom Listener
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const delta = -Math.sign(e.deltaY);
                renderer.zoomAt(x, y, delta);
                update();
            }, { passive: false });

            // ... (Clear/Undo listeners) ...
            inputs.clearBtn.addEventListener('click', () => {
                path = [];
                update();
            });

            inputs.undoBtn.addEventListener('click', () => {
                if (path.length > 0) {
                    path.pop();
                    update();
                }
            });

            // Mode Switching Logic
            let interactionMode = 'draw'; // 'draw', 'pan'
            let isPanning = false;
            let lastPanPos = { x: 0, y: 0 };

            const drawBtn = document.getElementById('drawBtn'); // Need to add this ID to HTML
            const panBtn = document.getElementById('panBtn');   // Need to add this ID to HTML

            if (drawBtn && panBtn) {
                drawBtn.addEventListener('click', () => setMode('draw'));
                panBtn.addEventListener('click', () => setMode('pan'));
            }

            function setMode(mode) {
                interactionMode = mode;
                canvas.style.cursor = mode === 'pan' ? 'grab' : 'crosshair';

                // Update UI state (active class)
                if (drawBtn) drawBtn.classList.toggle('active', mode === 'draw');
                if (panBtn) panBtn.classList.toggle('active', mode === 'pan');
            }

            // let currentMousePos = null; // Moved to global

            // handleCalibrationClick removed, logic moved to startDrawing

            function startDrawing(e) {
                // Calibration Logic (Priority)
                if (calibrationState === 'point1') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    calPoint1 = renderer.toWorld(x, y);

                    calibrationState = 'point2';
                    inputs.calibrationStatus.textContent = '点Bをクリックしてください (Click Point B)';
                    update();
                    return;
                }

                if (calibrationState === 'point2') {
                    // ... existing calibration logic ...
                    try {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        calPoint2 = renderer.toWorld(x, y);

                        if (!calPoint1) {
                            calibrationState = 'point1';
                            inputs.calibrationStatus.textContent = '点Aをクリックしてください (1/2)';
                            update();
                            return;
                        }

                        const distWorld = Math.hypot(calPoint2.x - calPoint1.x, calPoint2.y - calPoint1.y);
                        tempDistImagePixels = distWorld / bgMetersPerPixel;

                        // Show Modal
                        inputs.calibrationModal.style.display = 'block';
                        inputs.calDistanceInput.focus();

                        update(); // Show point B
                    } catch (err) {
                        console.error(err);
                        calibrationState = 'none';
                        update();
                    }
                    return;
                }

                // Pan Mode Logic
                if (interactionMode === 'pan') {
                    isPanning = true;
                    lastPanPos = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                    return;
                }

                // Normal Drawing Logic
                if (calibrationState !== 'none') return;

                isDrawing = true;
                addPoint(e);
            }

            function draw(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Pan Logic
                if (isPanning) {
                    const dx = e.clientX - lastPanPos.x;
                    const dy = e.clientY - lastPanPos.y;
                    renderer.pan(dx, dy);
                    lastPanPos = { x: e.clientX, y: e.clientY };
                    update();
                    return;
                }

                const worldPos = renderer.toWorld(x, y);

                // Update global mouse position for calibration visualization & Preview
                currentMousePos = worldPos;

                if (calibrationState === 'point2') {
                    update(); // Redraw to show dynamic line
                    return;
                }

                // Always update to show preview (if enabled)
                if (interactionMode === 'draw' && !isPanning && calibrationState === 'none') {
                    update();
                }

                if (!isDrawing) return;

                addPoint(e, true);
            }

            function stopDrawing() {
                if (isPanning) {
                    isPanning = false;
                    canvas.style.cursor = 'grab';
                }
                isDrawing = false;
                update();
            }


            // Override mouseleave to clear rubber-band
            canvas.removeEventListener('mouseleave', stopDrawing); // Remove old listener
            canvas.addEventListener('mouseleave', (e) => {
                isDrawing = false;
                currentMousePos = null;
                update();
            });

            function addPoint(e, isDragging = false) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = renderer.toWorld(x, y);

                if (path.length > 0) {
                    const last = path[path.length - 1];
                    const dist = Math.hypot(worldPos.x - last.x, worldPos.y - last.y);

                    const threshold = isDragging ? 0.5 : 0.1;
                    if (dist < threshold) return;
                }
                path.push(worldPos);
                update();
            }

            function update() {
                renderer.clear();

                // 1. Draw Center Line (Committed + Rubber band)
                renderer.drawPath(path, currentMousePos);

                // 2. Simulate & Draw Vehicle (Committed + Preview)
                // Construct path for simulation
                let simPath = [...path];
                if (interactionMode === 'draw' && !isPanning && currentMousePos && calibrationState === 'none') {
                    if (path.length > 0) {
                        const last = path[path.length - 1];
                        const dist = Math.hypot(currentMousePos.x - last.x, currentMousePos.y - last.y);
                        if (dist > 0.1) {
                            simPath.push(currentMousePos);
                        }
                    }
                }

                // Debug Preview
                // console.log(`Path: ${path.length}, SimPath: ${simPath.length}, Mouse: ${currentMousePos ? 'Yes' : 'No'}`);

                if (simPath.length > 1) {
                    const states = engine.simulate(simPath, vehicle);
                    renderer.drawSimulation(states, vehicle);
                }
            }


            class DxfWriter {
                constructor(version = 'AC1032') {
                    this.version = version;
                    this.content = [];
                    this.handleCount = 0;
                    this.addHeader();
                    this.addClasses();
                    this.addTables();
                    this.addBlocks();
                    this.content.push("0\r\nSECTION\r\n2\r\nENTITIES\r\n");
                }

                nextHandle() {
                    this.handleCount++;
                    return this.handleCount.toString(16).toUpperCase();
                }

                formatFloat(val) {
                    if (typeof val !== 'number' || isNaN(val) || !isFinite(val)) return "0.0000";
                    return val.toFixed(4);
                }

                addHeader() {
                    this.content.push("0\r\nSECTION\r\n2\r\nHEADER\r\n");
                    this.content.push("9\r\n$ACADVER\r\n1\r\n" + this.version + "\r\n");
                    this.content.push("9\r\n$INSUNITS\r\n70\r\n6\r\n"); // 6 = Meters
                    this.content.push("9\r\n$HANDSEED\r\n5\r\nFFFF\r\n");
                    this.content.push("0\r\nENDSEC\r\n");
                }

                addClasses() {
                    if (this.version === 'AC1009') return;
                    this.content.push("0\r\nSECTION\r\n2\r\nCLASSES\r\n0\r\nENDSEC\r\n");
                }

                addTables() {
                    this.content.push("0\r\nSECTION\r\n2\r\nTABLES\r\n");
                    this.addVPortTable();
                    this.addLTypeTable();
                    this.addLayerTable();
                    this.addStyleTable();
                    this.addViewTable();
                    this.addUcsTable();
                    this.addAppIdTable();
                    this.addDimStyleTable();
                    this.addBlockRecordTable();
                    this.content.push("0\r\nENDSEC\r\n");
                }

                addVPortTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nVPORT\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addLTypeTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nLTYPE\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n1\r\n");
                    this.content.push("0\r\nLTYPE\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTableRecord\r\n100\r\nAcDbLinetypeTableRecord\r\n");
                    this.content.push("2\r\nCONTINUOUS\r\n70\r\n0\r\n3\r\nSolid line\r\n72\r\n65\r\n73\r\n0\r\n40\r\n0.0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addLayerTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nLAYER\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n4\r\n");
                    this.addLayer("0", 7);
                    this.addLayer("Trajectory_Tractor", 1);
                    this.addLayer("Trajectory_Trailer", 3);
                    this.addLayer("Swept_Path", 5);
                    this.addLayer("Vehicle_Body", 7); // White/Black
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addLayer(name, color) {
                    this.content.push("0\r\nLAYER\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') {
                        this.content.push("100\r\nAcDbSymbolTableRecord\r\n100\r\nAcDbLayerTableRecord\r\n");
                    }
                    this.content.push("2\r\n" + name + "\r\n70\r\n0\r\n62\r\n" + color + "\r\n6\r\nCONTINUOUS\r\n");
                }

                addStyleTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nSTYLE\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addViewTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nVIEW\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addUcsTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nUCS\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addAppIdTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nAPPID\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n1\r\n");
                    this.content.push("0\r\nAPPID\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTableRecord\r\n100\r\nAcDbRegAppTableRecord\r\n");
                    this.content.push("2\r\nACAD\r\n70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addDimStyleTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nDIMSTYLE\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n0\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addBlockRecordTable() {
                    this.content.push("0\r\nTABLE\r\n2\r\nBLOCK_RECORD\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTable\r\n");
                    this.content.push("70\r\n2\r\n");
                    // Model Space
                    this.content.push("0\r\nBLOCK_RECORD\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTableRecord\r\n100\r\nAcDbBlockTableRecord\r\n");
                    this.content.push("2\r\n*Model_Space\r\n");
                    // Paper Space
                    this.content.push("0\r\nBLOCK_RECORD\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbSymbolTableRecord\r\n100\r\nAcDbBlockTableRecord\r\n");
                    this.content.push("2\r\n*Paper_Space\r\n");
                    this.content.push("0\r\nENDTAB\r\n");
                }

                addBlocks() {
                    this.content.push("0\r\nSECTION\r\n2\r\nBLOCKS\r\n");
                    // Model Space Block
                    this.content.push("0\r\nBLOCK\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbEntity\r\n8\r\n0\r\n100\r\nAcDbBlockBegin\r\n");
                    this.content.push("2\r\n*Model_Space\r\n70\r\n0\r\n10\r\n0.0\r\n20\r\n0.0\r\n30\r\n0.0\r\n3\r\n*Model_Space\r\n1\r\n\r\n");
                    this.content.push("0\r\nENDBLK\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbEntity\r\n8\r\n0\r\n100\r\nAcDbBlockEnd\r\n");
                    // Paper Space Block
                    this.content.push("0\r\nBLOCK\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbEntity\r\n8\r\n0\r\n100\r\nAcDbBlockBegin\r\n");
                    this.content.push("2\r\n*Paper_Space\r\n70\r\n0\r\n10\r\n0.0\r\n20\r\n0.0\r\n30\r\n0.0\r\n3\r\n*Paper_Space\r\n1\r\n\r\n");
                    this.content.push("0\r\nENDBLK\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("100\r\nAcDbEntity\r\n8\r\n0\r\n100\r\nAcDbBlockEnd\r\n");
                    this.content.push("0\r\nENDSEC\r\n");
                }

                addPolyline(points, layer = "0") {
                    if (points.length < 2) return;

                    this.content.push("0\r\nLWPOLYLINE\r\n5\r\n" + this.nextHandle() + "\r\n");
                    if (this.version !== 'AC1009') this.content.push("330\r\n" + this.nextHandle() + "\r\n100\r\nAcDbEntity\r\n");
                    this.content.push("8\r\n" + layer + "\r\n100\r\nAcDbPolyline\r\n90\r\n" + points.length + "\r\n70\r\n0\r\n"); // 70 = 0 for default polyline flags

                    points.forEach(p => {
                        this.content.push("10\r\n" + this.formatFloat(p.x) + "\r\n20\r\n" + this.formatFloat(p.y) + "\r\n");
                    });
                }

                toDxfString() {
                    this.content.push("0\r\nENDSEC\r\n0\r\nEOF\r\n");
                    return this.content.join('');
                }

                toBlob() {
                    return new Blob([this.toDxfString()], { type: 'application/dxf' });
                }
            }



            inputs.exportDxfBtn.addEventListener('click', () => {
                try {
                    if (path.length < 2) {
                        alert("軌跡を描画してください (Please draw a path first)");
                        return;
                    }

                    const states = engine.simulate(path, vehicle);
                    if (!states || states.length === 0) return;

                    const selectedVersion = 'AC1032';
                    const dxf = new DxfWriter(selectedVersion);

                    // 1. Tractor Path (Red) - Rear Axle Center
                    // DXF Y is usually Up. Flip Y for CAD compatibility.
                    const flipY = (pts) => pts.map(p => ({ x: p.x, y: -p.y }));

                    dxf.addPolyline(flipY(states), "Trajectory_Tractor");

                    // 2. Trailer Path (Green)
                    if (vehicle.hasTrailer) {
                        const trailerPath = states.map(s => s.trailer);
                        dxf.addPolyline(flipY(trailerPath), "Trajectory_Trailer");
                    }

                    // 3. Swept Path (Blue)
                    // Tractor FL
                    dxf.addPolyline(flipY(states.map(s => s.envelope.tractor.fl)), "Swept_Path");
                    // Tractor FR
                    dxf.addPolyline(flipY(states.map(s => s.envelope.tractor.fr)), "Swept_Path");

                    if (vehicle.hasTrailer) {
                        dxf.addPolyline(flipY(states.map(s => s.envelope.trailer.rl)), "Swept_Path");
                        dxf.addPolyline(flipY(states.map(s => s.envelope.trailer.rr)), "Swept_Path");
                    } else {
                        dxf.addPolyline(flipY(states.map(s => s.envelope.tractor.rl)), "Swept_Path");
                        dxf.addPolyline(flipY(states.map(s => s.envelope.tractor.rr)), "Swept_Path");
                    }

                    // 4. Vehicle Body (White/Black)
                    const step = Math.floor(states.length / 10) || 1;

                    const getRectCorners = (cx, cy, heading, lenFront, lenRear, width) => {
                        const halfW = width / 2;
                        // Corners relative to center
                        const corners = [
                            { lx: lenFront, ly: halfW },
                            { lx: lenFront, ly: -halfW },
                            { lx: -lenRear, ly: -halfW },
                            { lx: -lenRear, ly: halfW },
                            { lx: lenFront, ly: halfW } // Close loop
                        ];

                        return corners.map(c => engine.transformPoint(c.lx, c.ly, cx, cy, heading));
                    };

                    for (let i = 0; i < states.length; i += step) {
                        const s = states[i];

                        // Tractor
                        const trFront = vehicle.wheelbase + vehicle.overhangFront;
                        const trRear = vehicle.overhangRear;
                        const trPts = getRectCorners(s.x, s.y, s.heading, trFront, trRear, vehicle.width);
                        dxf.addPolyline(flipY(trPts), "Vehicle_Body");

                        // Trailer
                        if (vehicle.hasTrailer && s.trailer) {
                            const tFront = vehicle.trailerWheelbase;
                            const tRear = vehicle.trailerOverhangRear;
                            const tPts = getRectCorners(s.trailer.x, s.trailer.y, s.trailer.heading, tFront, tRear, vehicle.trailerWidth);
                            dxf.addPolyline(flipY(tPts), "Vehicle_Body");
                        }
                    }
                    // Always draw last one
                    const lastS = states[states.length - 1];
                    const trFront = vehicle.wheelbase + vehicle.overhangFront;
                    const trRear = vehicle.overhangRear;
                    const trPts = getRectCorners(lastS.x, lastS.y, lastS.heading, trFront, trRear, vehicle.width);
                    dxf.addPolyline(flipY(trPts), "Vehicle_Body");

                    if (vehicle.hasTrailer && lastS.trailer) {
                        const tFront = vehicle.trailerWheelbase;
                        const tRear = vehicle.trailerOverhangRear;
                        const tPts = getRectCorners(lastS.trailer.x, lastS.trailer.y, lastS.trailer.heading, tFront, tRear, vehicle.trailerWidth);
                        dxf.addPolyline(flipY(tPts), "Vehicle_Body");
                    }

                    // Download
                    const blob = dxf.toBlob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `trajectory_${selectedVersion}.dxf`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    alert("Export Error: " + e.message);
                    console.error(e);
                }
            });
        });
    </script>

</body>